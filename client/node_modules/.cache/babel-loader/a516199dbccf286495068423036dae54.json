{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { equal } from '@wry/equality';\nimport { mergeOptions } from \"../../core/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nexport function useQuery(query, options) {\n  var _a;\n\n  var context = useContext(getApolloContext());\n  var client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);\n  var defaultWatchQueryOptions = client.defaultOptions.watchQuery;\n  verifyDocumentType(query, DocumentType.Query);\n\n  var _b = useState(function () {\n    var watchQueryOptions = createWatchQueryOptions(query, options, defaultWatchQueryOptions);\n    var obsQuery = null;\n\n    if (context.renderPromises) {\n      obsQuery = context.renderPromises.getSSRObservable(watchQueryOptions);\n    }\n\n    if (!obsQuery) {\n      obsQuery = client.watchQuery(watchQueryOptions);\n\n      if (context.renderPromises) {\n        context.renderPromises.registerSSRObservable(obsQuery, watchQueryOptions);\n      }\n    }\n\n    if (context.renderPromises && (options === null || options === void 0 ? void 0 : options.ssr) !== false && !(options === null || options === void 0 ? void 0 : options.skip) && obsQuery.getCurrentResult().loading) {\n      context.renderPromises.addQueryPromise({\n        getOptions: function () {\n          return createWatchQueryOptions(query, options, defaultWatchQueryOptions);\n        },\n        fetchData: function () {\n          return new Promise(function (resolve) {\n            var sub = obsQuery.subscribe({\n              next: function (result) {\n                if (!result.loading) {\n                  resolve();\n                  sub.unsubscribe();\n                }\n              },\n              error: function () {\n                resolve();\n                sub.unsubscribe();\n              },\n              complete: function () {\n                resolve();\n              }\n            });\n          });\n        }\n      }, function () {\n        return null;\n      });\n    }\n\n    return obsQuery;\n  }),\n      obsQuery = _b[0],\n      setObsQuery = _b[1];\n\n  var _c = useState(function () {\n    var _a, _b;\n\n    var result = obsQuery.getCurrentResult();\n\n    if (!result.loading && options) {\n      if (result.error) {\n        (_a = options.onError) === null || _a === void 0 ? void 0 : _a.call(options, result.error);\n      } else if (result.data) {\n        (_b = options.onCompleted) === null || _b === void 0 ? void 0 : _b.call(options, result.data);\n      }\n    }\n\n    return result;\n  }),\n      result = _c[0],\n      setResult = _c[1];\n\n  var ref = useRef({\n    client: client,\n    query: query,\n    options: options,\n    result: result,\n    previousData: void 0,\n    watchQueryOptions: createWatchQueryOptions(query, options, defaultWatchQueryOptions)\n  });\n  useEffect(function () {\n    var _a, _b;\n\n    var watchQueryOptions = createWatchQueryOptions(query, options, defaultWatchQueryOptions);\n    var nextResult;\n\n    if (ref.current.client !== client || !equal(ref.current.query, query)) {\n      var obsQuery_1 = client.watchQuery(watchQueryOptions);\n      setObsQuery(obsQuery_1);\n      nextResult = obsQuery_1.getCurrentResult();\n    } else if (!equal(ref.current.watchQueryOptions, watchQueryOptions)) {\n      obsQuery.setOptions(watchQueryOptions).catch(function () {});\n      nextResult = obsQuery.getCurrentResult();\n      ref.current.watchQueryOptions = watchQueryOptions;\n    }\n\n    if (nextResult) {\n      var previousResult = ref.current.result;\n\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n\n      setResult(ref.current.result = nextResult);\n\n      if (!nextResult.loading && options) {\n        if (nextResult.error) {\n          (_a = options.onError) === null || _a === void 0 ? void 0 : _a.call(options, nextResult.error);\n        } else if (nextResult.data) {\n          (_b = options.onCompleted) === null || _b === void 0 ? void 0 : _b.call(options, nextResult.data);\n        }\n      }\n    }\n\n    Object.assign(ref.current, {\n      client: client,\n      query: query\n    });\n  }, [obsQuery, client, query, options]);\n  useEffect(function () {\n    if (context.renderPromises) {\n      return;\n    }\n\n    var subscription = obsQuery.subscribe(onNext, onError);\n\n    function onNext() {\n      var _a, _b;\n\n      var previousResult = ref.current.result;\n      var result = obsQuery.getCurrentResult();\n\n      if (previousResult && previousResult.loading === result.loading && previousResult.networkStatus === result.networkStatus && equal(previousResult.data, result.data)) {\n        return;\n      }\n\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n\n      setResult(ref.current.result = result);\n\n      if (!result.loading) {\n        (_b = (_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onCompleted) === null || _b === void 0 ? void 0 : _b.call(_a, result.data);\n      }\n    }\n\n    function onError(error) {\n      var _a, _b;\n\n      var last = obsQuery[\"last\"];\n      subscription.unsubscribe();\n\n      try {\n        obsQuery.resetLastResults();\n        subscription = obsQuery.subscribe(onNext, onError);\n      } finally {\n        obsQuery[\"last\"] = last;\n      }\n\n      if (!error.hasOwnProperty('graphQLErrors')) {\n        throw error;\n      }\n\n      var previousResult = ref.current.result;\n\n      if (previousResult && previousResult.loading || !equal(error, previousResult.error)) {\n        setResult(ref.current.result = {\n          data: previousResult.data,\n          error: error,\n          loading: false,\n          networkStatus: NetworkStatus.error\n        });\n        (_b = (_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onError) === null || _b === void 0 ? void 0 : _b.call(_a, error);\n      }\n    }\n\n    return function () {\n      return subscription.unsubscribe();\n    };\n  }, [obsQuery, context.renderPromises, client.disableNetworkFetches]);\n  var partial;\n  _a = result, partial = _a.partial, result = __rest(_a, [\"partial\"]);\n  {\n    if (partial && (options === null || options === void 0 ? void 0 : options.partialRefetch) && !result.loading && (!result.data || Object.keys(result.data).length === 0) && obsQuery.options.fetchPolicy !== 'cache-only') {\n      result = __assign(__assign({}, result), {\n        loading: true,\n        networkStatus: NetworkStatus.refetch\n      });\n      obsQuery.refetch();\n    }\n\n    if (context.renderPromises && (options === null || options === void 0 ? void 0 : options.ssr) !== false && !(options === null || options === void 0 ? void 0 : options.skip) && result.loading) {\n      obsQuery.setOptions(createWatchQueryOptions(query, options, defaultWatchQueryOptions)).catch(function () {});\n    }\n\n    Object.assign(ref.current, {\n      options: options\n    });\n  }\n\n  if ((context.renderPromises || client.disableNetworkFetches) && (options === null || options === void 0 ? void 0 : options.ssr) === false) {\n    result = ref.current.result = {\n      loading: true,\n      data: void 0,\n      error: void 0,\n      networkStatus: NetworkStatus.loading\n    };\n  } else if ((options === null || options === void 0 ? void 0 : options.skip) || (options === null || options === void 0 ? void 0 : options.fetchPolicy) === 'standby') {\n    result = {\n      loading: false,\n      data: void 0,\n      error: void 0,\n      networkStatus: NetworkStatus.ready\n    };\n  }\n\n  if (result.errors && result.errors.length) {\n    result = __assign(__assign({}, result), {\n      error: result.error || new ApolloError({\n        graphQLErrors: result.errors\n      })\n    });\n  }\n\n  var obsQueryFields = useMemo(function () {\n    return {\n      refetch: obsQuery.refetch.bind(obsQuery),\n      fetchMore: obsQuery.fetchMore.bind(obsQuery),\n      updateQuery: obsQuery.updateQuery.bind(obsQuery),\n      startPolling: obsQuery.startPolling.bind(obsQuery),\n      stopPolling: obsQuery.stopPolling.bind(obsQuery),\n      subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery)\n    };\n  }, [obsQuery]);\n  return __assign(__assign(__assign({}, obsQueryFields), {\n    variables: createWatchQueryOptions(query, options, defaultWatchQueryOptions).variables,\n    client: client,\n    called: true,\n    previousData: ref.current.previousData\n  }), result);\n}\n\nfunction createWatchQueryOptions(query, options, defaultOptions) {\n  var _a;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  var skip = options.skip,\n      ssr = options.ssr,\n      onCompleted = options.onCompleted,\n      onError = options.onError,\n      displayName = options.displayName,\n      otherOptions = __rest(options, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"displayName\"]);\n\n  var watchQueryOptions = __assign({\n    query: query\n  }, otherOptions);\n\n  if (defaultOptions) {\n    watchQueryOptions = mergeOptions(defaultOptions, watchQueryOptions);\n  }\n\n  if (skip) {\n    watchQueryOptions.fetchPolicy = 'standby';\n  } else if (((_a = watchQueryOptions.context) === null || _a === void 0 ? void 0 : _a.renderPromises) && (watchQueryOptions.fetchPolicy === 'network-only' || watchQueryOptions.fetchPolicy === 'cache-and-network')) {\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  } else if (!watchQueryOptions.fetchPolicy) {\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  }\n\n  if (!watchQueryOptions.variables) {\n    watchQueryOptions.variables = {};\n  }\n\n  return watchQueryOptions;\n}","map":{"version":3,"mappings":"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","names":["useContext","useEffect","useMemo","useRef","useState","equal","mergeOptions","getApolloContext","ApolloError","NetworkStatus","DocumentType","verifyDocumentType","useApolloClient","useQuery","query","options","_a","context","client","defaultWatchQueryOptions","defaultOptions","watchQuery","Query","watchQueryOptions","createWatchQueryOptions","obsQuery","renderPromises","getSSRObservable","registerSSRObservable","ssr","skip","getCurrentResult","loading","addQueryPromise","getOptions","fetchData","Promise","resolve","sub","subscribe","next","result","unsubscribe","error","complete","setObsQuery","_b","onError","data","onCompleted","setResult","ref","previousData","nextResult","current","obsQuery_1","setOptions","catch","previousResult","Object","assign","subscription","onNext","networkStatus","last","resetLastResults","hasOwnProperty","disableNetworkFetches","partial","partialRefetch","keys","length","fetchPolicy","refetch","ready","errors","graphQLErrors","obsQueryFields","bind","fetchMore","updateQuery","startPolling","stopPolling","subscribeToMore","variables","called","displayName","otherOptions"],"sources":["../../../src/react/hooks/useQuery.ts"],"sourcesContent":["import { useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { equal } from '@wry/equality';\nimport { OperationVariables, mergeOptions } from '../../core';\nimport { getApolloContext } from '../context';\nimport { ApolloError } from '../../errors';\nimport {\n  ApolloQueryResult,\n  NetworkStatus,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from '../../core';\nimport {\n  QueryHookOptions,\n  QueryResult,\n} from '../types/types';\n\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport { useApolloClient } from './useApolloClient';\n\nexport function useQuery<\n  TData = any,\n  TVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: QueryHookOptions<TData, TVariables>,\n): QueryResult<TData, TVariables> {\n  const context = useContext(getApolloContext());\n  const client = useApolloClient(options?.client);\n  const defaultWatchQueryOptions = client.defaultOptions.watchQuery;\n  verifyDocumentType(query, DocumentType.Query);\n  const [obsQuery, setObsQuery] = useState(() => {\n    const watchQueryOptions = createWatchQueryOptions(query, options, defaultWatchQueryOptions);\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    let obsQuery: ObservableQuery<TData, TVariables> | null = null;\n    if (context.renderPromises) {\n      obsQuery = context.renderPromises.getSSRObservable(watchQueryOptions);\n    }\n\n    if (!obsQuery) {\n      // Is it safe (StrictMode/memory-wise) to call client.watchQuery here?\n      obsQuery = client.watchQuery(watchQueryOptions);\n      if (context.renderPromises) {\n        context.renderPromises.registerSSRObservable(\n          obsQuery,\n          watchQueryOptions,\n        );\n      }\n    }\n\n    if (\n      context.renderPromises &&\n      options?.ssr !== false &&\n      !options?.skip &&\n      obsQuery.getCurrentResult().loading\n    ) {\n      // TODO: This is a legacy API which could probably be cleaned up\n      context.renderPromises.addQueryPromise(\n        {\n          // The only options which seem to actually be used by the\n          // RenderPromises class are query and variables.\n          getOptions: () => createWatchQueryOptions(query, options, defaultWatchQueryOptions),\n          fetchData: () => new Promise<void>((resolve) => {\n            const sub = obsQuery!.subscribe({\n              next(result) {\n                if (!result.loading) {\n                  resolve()\n                  sub.unsubscribe();\n                }\n              },\n              error() {\n                resolve();\n                sub.unsubscribe();\n              },\n              complete() {\n                resolve();\n              },\n            });\n          }),\n        },\n        // This callback never seemed to do anything\n        () => null,\n      );\n    }\n\n    return obsQuery;\n  });\n\n  let [result, setResult] = useState(() => {\n    const result = obsQuery.getCurrentResult();\n    if (!result.loading && options) {\n      if (result.error) {\n        options.onError?.(result.error);\n      } else if (result.data) {\n        options.onCompleted?.(result.data);\n      }\n    }\n\n    return result;\n  });\n\n  const ref = useRef({\n    client,\n    query,\n    options,\n    result,\n    previousData: void 0 as TData | undefined,\n    watchQueryOptions: createWatchQueryOptions(query, options, defaultWatchQueryOptions),\n  });\n\n  // An effect to recreate the obsQuery whenever the client or query changes.\n  // This effect is also responsible for checking and updating the obsQuery\n  // options whenever they change.\n  useEffect(() => {\n    const watchQueryOptions = createWatchQueryOptions(query, options, defaultWatchQueryOptions);\n    let nextResult: ApolloQueryResult<TData> | undefined;\n    if (ref.current.client !== client || !equal(ref.current.query, query)) {\n      const obsQuery = client.watchQuery(watchQueryOptions);\n      setObsQuery(obsQuery);\n      nextResult = obsQuery.getCurrentResult();\n    } else if (!equal(ref.current.watchQueryOptions, watchQueryOptions)) {\n      obsQuery.setOptions(watchQueryOptions).catch(() => {});\n      nextResult = obsQuery.getCurrentResult();\n      ref.current.watchQueryOptions = watchQueryOptions;\n    }\n\n    if (nextResult) {\n      const previousResult = ref.current.result;\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n\n      setResult(ref.current.result = nextResult);\n      if (!nextResult.loading && options) {\n        if (nextResult.error) {\n          options.onError?.(nextResult.error);\n        } else if (nextResult.data) {\n          options.onCompleted?.(nextResult.data);\n        }\n      }\n    }\n\n    Object.assign(ref.current, { client, query });\n  }, [obsQuery, client, query, options]);\n\n  // An effect to subscribe to the current observable query\n  useEffect(() => {\n    if (context.renderPromises) {\n      return;\n    }\n\n    let subscription = obsQuery.subscribe(onNext, onError);\n    // We use `getCurrentResult()` instead of the callback argument because\n    // the values differ slightly. Specifically, loading results will have\n    // an empty object for data instead of `undefined` for some reason.\n    function onNext() {\n      const previousResult = ref.current.result;\n      const result = obsQuery.getCurrentResult();\n      // Make sure we're not attempting to re-render similar results\n      if (\n        previousResult &&\n        previousResult.loading === result.loading &&\n        previousResult.networkStatus === result.networkStatus &&\n        equal(previousResult.data, result.data)\n      ) {\n        return;\n      }\n\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n\n      setResult(ref.current.result = result);\n      if (!result.loading) {\n        ref.current.options?.onCompleted?.(result.data);\n      }\n    }\n\n    function onError(error: Error) {\n      const last = obsQuery[\"last\"];\n      subscription.unsubscribe();\n      // Unfortunately, if `lastError` is set in the current\n      // `observableQuery` when the subscription is re-created,\n      // the subscription will immediately receive the error, which will\n      // cause it to terminate again. To avoid this, we first clear\n      // the last error/result from the `observableQuery` before re-starting\n      // the subscription, and restore it afterwards (so the subscription\n      // has a chance to stay open).\n      try {\n        obsQuery.resetLastResults();\n        subscription = obsQuery.subscribe(onNext, onError);\n      } finally {\n        obsQuery[\"last\"] = last;\n      }\n\n      if (!error.hasOwnProperty('graphQLErrors')) {\n        // The error is not a GraphQL error\n        throw error;\n      }\n\n      const previousResult = ref.current.result;\n      if (\n        (previousResult && previousResult.loading) ||\n        !equal(error, previousResult.error)\n      ) {\n        setResult(ref.current.result = {\n          data: previousResult.data,\n          error: error as ApolloError,\n          loading: false,\n          networkStatus: NetworkStatus.error,\n        });\n        ref.current.options?.onError?.(error as ApolloError);\n      }\n    }\n\n    return () => subscription.unsubscribe();\n  }, [obsQuery, context.renderPromises, client.disableNetworkFetches]);\n\n  let partial: boolean | undefined;\n  ({ partial, ...result } = result);\n\n  {\n    // BAD BOY CODE BLOCK WHERE WE PUT SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (\n      partial &&\n      options?.partialRefetch &&\n      !result.loading &&\n      (!result.data || Object.keys(result.data).length === 0) &&\n      obsQuery.options.fetchPolicy !== 'cache-only'\n    ) {\n      result = {\n        ...result,\n        loading: true,\n        networkStatus: NetworkStatus.refetch,\n      };\n\n      obsQuery.refetch();\n    }\n\n    // TODO: This is a hack to make sure useLazyQuery executions update the\n    // obsevable query options for ssr.\n    if (\n      context.renderPromises &&\n      options?.ssr !== false &&\n      !options?.skip &&\n      result.loading\n    ) {\n      obsQuery.setOptions(createWatchQueryOptions(query, options, defaultWatchQueryOptions)).catch(() => {});\n    }\n\n    // We assign options during rendering as a guard to make sure that\n    // callbacks like onCompleted and onError are not stale.\n    Object.assign(ref.current, { options });\n  }\n\n  if (\n    (context.renderPromises || client.disableNetworkFetches) &&\n    options?.ssr === false\n  ) {\n    // If SSR has been explicitly disabled, and this function has been called\n    // on the server side, return the default loading state.\n    result = ref.current.result = {\n      loading: true,\n      data: void 0 as unknown as TData,\n      error: void 0,\n      networkStatus: NetworkStatus.loading,\n    };\n  } else if (options?.skip || options?.fetchPolicy === 'standby') {\n    // When skipping a query (ie. we're not querying for data but still want to\n    // render children), make sure the `data` is cleared out and `loading` is\n    // set to `false` (since we aren't loading anything).\n    //\n    // NOTE: We no longer think this is the correct behavior. Skipping should\n    // not automatically set `data` to `undefined`, but instead leave the\n    // previous data in place. In other words, skipping should not mandate that\n    // previously received data is all of a sudden removed. Unfortunately,\n    // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n    // to address this.\n    result = {\n      loading: false,\n      data: void 0 as unknown as TData,\n      error: void 0,\n      networkStatus: NetworkStatus.ready,\n    };\n  }\n\n  if (result.errors && result.errors.length) {\n    // Until a set naming convention for networkError and graphQLErrors is\n    // decided upon, we map errors (graphQLErrors) to the error options.\n    // TODO: Is it possible for both result.error and result.errors to be\n    // defined here?\n    result = {\n      ...result,\n      error: result.error || new ApolloError({ graphQLErrors: result.errors }),\n    };\n  }\n\n  const obsQueryFields = useMemo(() => ({\n    refetch: obsQuery.refetch.bind(obsQuery),\n    fetchMore: obsQuery.fetchMore.bind(obsQuery),\n    updateQuery: obsQuery.updateQuery.bind(obsQuery),\n    startPolling: obsQuery.startPolling.bind(obsQuery),\n    stopPolling: obsQuery.stopPolling.bind(obsQuery),\n    subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n  }), [obsQuery]);\n\n  return {\n    ...obsQueryFields,\n    variables: createWatchQueryOptions(query, options, defaultWatchQueryOptions).variables,\n    client,\n    called: true,\n    previousData: ref.current.previousData,\n    ...result,\n  };\n}\n\n/**\n * A function to massage options before passing them the ObservableQuery.\n */\nfunction createWatchQueryOptions<TData, TVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<TData, TVariables> = {},\n  defaultOptions?: Partial<WatchQueryOptions<any, any>>\n): WatchQueryOptions<TVariables, TData> {\n  // TODO: For some reason, we pass context, which is the React Apollo Context,\n  // into observable queries, and test for that.\n  // removing hook specific options\n  const {\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    displayName,\n    ...otherOptions\n  } = options;\n\n  let watchQueryOptions = { query, ...otherOptions };\n  if (defaultOptions) {\n    watchQueryOptions = mergeOptions(defaultOptions, watchQueryOptions);\n  }\n\n  if (skip) {\n    watchQueryOptions.fetchPolicy = 'standby';\n  } else if (\n    watchQueryOptions.context?.renderPromises &&\n    (\n      watchQueryOptions.fetchPolicy === 'network-only' ||\n      watchQueryOptions.fetchPolicy === 'cache-and-network'\n    )\n  ) {\n    // this behavior was added to react-apollo without explanation in this PR\n    // https://github.com/apollographql/react-apollo/pull/1579\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  } else if (!watchQueryOptions.fetchPolicy) {\n    // cache-first is the default policy, but we explicitly assign it here so\n    // the cache policies computed based on options can be cleared\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  }\n\n  if (!watchQueryOptions.variables) {\n    watchQueryOptions.variables = {} as TVariables;\n  }\n\n  return watchQueryOptions;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}