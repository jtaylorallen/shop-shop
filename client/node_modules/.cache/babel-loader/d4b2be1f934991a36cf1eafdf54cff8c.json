{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { equal } from '@wry/equality';\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { compact, cloneDeep, getOperationDefinition, Observable, iterateObserversSafely, isNonEmptyArray, fixObservableSubclass, getQueryDefinition } from \"../utilities/index.js\";\nvar assign = Object.assign,\n    hasOwnProperty = Object.hasOwnProperty;\nvar warnedAboutUpdateQuery = false;\n\nvar ObservableQuery = function (_super) {\n  __extends(ObservableQuery, _super);\n\n  function ObservableQuery(_a) {\n    var queryManager = _a.queryManager,\n        queryInfo = _a.queryInfo,\n        options = _a.options;\n\n    var _this = _super.call(this, function (observer) {\n      try {\n        var subObserver = observer._subscription._observer;\n\n        if (subObserver && !subObserver.error) {\n          subObserver.error = defaultSubscriptionObserverErrorCallback;\n        }\n      } catch (_a) {}\n\n      var first = !_this.observers.size;\n\n      _this.observers.add(observer);\n\n      var last = _this.last;\n\n      if (last && last.error) {\n        observer.error && observer.error(last.error);\n      } else if (last && last.result) {\n        observer.next && observer.next(last.result);\n      }\n\n      if (first) {\n        _this.reobserve().catch(function () {});\n      }\n\n      return function () {\n        if (_this.observers.delete(observer) && !_this.observers.size) {\n          _this.tearDownQuery();\n        }\n      };\n    }) || this;\n\n    _this.observers = new Set();\n    _this.subscriptions = new Set();\n    _this.isTornDown = false;\n    _this.options = options;\n    _this.queryId = queryInfo.queryId || queryManager.generateQueryId();\n    var opDef = getOperationDefinition(options.query);\n    _this.queryName = opDef && opDef.name && opDef.name.value;\n    _this.initialFetchPolicy = options.fetchPolicy || \"cache-first\";\n    _this.queryManager = queryManager;\n    _this.queryInfo = queryInfo;\n    return _this;\n  }\n\n  Object.defineProperty(ObservableQuery.prototype, \"variables\", {\n    get: function () {\n      return this.options.variables;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ObservableQuery.prototype.result = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var observer = {\n        next: function (result) {\n          resolve(result);\n\n          _this.observers.delete(observer);\n\n          if (!_this.observers.size) {\n            _this.queryManager.removeQuery(_this.queryId);\n          }\n\n          setTimeout(function () {\n            subscription.unsubscribe();\n          }, 0);\n        },\n        error: reject\n      };\n\n      var subscription = _this.subscribe(observer);\n    });\n  };\n\n  ObservableQuery.prototype.getCurrentResult = function (saveAsLastResult) {\n    if (saveAsLastResult === void 0) {\n      saveAsLastResult = true;\n    }\n\n    var lastResult = this.getLastResult(true);\n    var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || NetworkStatus.ready;\n\n    var result = __assign(__assign({}, lastResult), {\n      loading: isNetworkRequestInFlight(networkStatus),\n      networkStatus: networkStatus\n    });\n\n    var _a = this.options.fetchPolicy,\n        fetchPolicy = _a === void 0 ? \"cache-first\" : _a;\n\n    if (fetchPolicy === 'network-only' || fetchPolicy === 'no-cache' || fetchPolicy === 'standby' || this.queryManager.transform(this.options.query).hasForcedResolvers) {} else {\n      var diff = this.queryInfo.getDiff();\n\n      if (diff.complete || this.options.returnPartialData) {\n        result.data = diff.result;\n      }\n\n      if (equal(result.data, {})) {\n        result.data = void 0;\n      }\n\n      if (diff.complete) {\n        delete result.partial;\n\n        if (diff.complete && result.networkStatus === NetworkStatus.loading && (fetchPolicy === 'cache-first' || fetchPolicy === 'cache-only')) {\n          result.networkStatus = NetworkStatus.ready;\n          result.loading = false;\n        }\n      } else {\n        result.partial = true;\n      }\n\n      if (__DEV__ && !diff.complete && !this.options.partialRefetch && !result.loading && !result.data && !result.error) {\n        logMissingFieldErrors(diff.missing);\n      }\n    }\n\n    if (saveAsLastResult) {\n      this.updateLastResult(result);\n    }\n\n    return result;\n  };\n\n  ObservableQuery.prototype.isDifferentFromLastResult = function (newResult) {\n    return !this.last || !equal(this.last.result, newResult);\n  };\n\n  ObservableQuery.prototype.getLast = function (key, variablesMustMatch) {\n    var last = this.last;\n\n    if (last && last[key] && (!variablesMustMatch || equal(last.variables, this.variables))) {\n      return last[key];\n    }\n  };\n\n  ObservableQuery.prototype.getLastResult = function (variablesMustMatch) {\n    return this.getLast(\"result\", variablesMustMatch);\n  };\n\n  ObservableQuery.prototype.getLastError = function (variablesMustMatch) {\n    return this.getLast(\"error\", variablesMustMatch);\n  };\n\n  ObservableQuery.prototype.resetLastResults = function () {\n    delete this.last;\n    this.isTornDown = false;\n  };\n\n  ObservableQuery.prototype.resetQueryStoreErrors = function () {\n    this.queryManager.resetErrors(this.queryId);\n  };\n\n  ObservableQuery.prototype.refetch = function (variables) {\n    var _a;\n\n    var reobserveOptions = {\n      pollInterval: 0\n    };\n    var fetchPolicy = this.options.fetchPolicy;\n\n    if (fetchPolicy === 'cache-and-network') {\n      reobserveOptions.fetchPolicy = fetchPolicy;\n    } else if (fetchPolicy === 'no-cache') {\n      reobserveOptions.fetchPolicy = 'no-cache';\n    } else {\n      reobserveOptions.fetchPolicy = 'network-only';\n    }\n\n    if (__DEV__ && variables && hasOwnProperty.call(variables, \"variables\")) {\n      var queryDef = getQueryDefinition(this.options.query);\n      var vars = queryDef.variableDefinitions;\n\n      if (!vars || !vars.some(function (v) {\n        return v.variable.name.value === \"variables\";\n      })) {\n        __DEV__ && invariant.warn(\"Called refetch(\".concat(JSON.stringify(variables), \") for query \").concat(((_a = queryDef.name) === null || _a === void 0 ? void 0 : _a.value) || JSON.stringify(queryDef), \", which does not declare a $variables variable.\\nDid you mean to call refetch(variables) instead of refetch({ variables })?\"));\n      }\n    }\n\n    if (variables && !equal(this.options.variables, variables)) {\n      reobserveOptions.variables = this.options.variables = __assign(__assign({}, this.options.variables), variables);\n    }\n\n    this.queryInfo.resetLastWrite();\n    return this.reobserve(reobserveOptions, NetworkStatus.refetch);\n  };\n\n  ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {\n    var _this = this;\n\n    var combinedOptions = __assign(__assign({}, fetchMoreOptions.query ? fetchMoreOptions : __assign(__assign(__assign({}, this.options), fetchMoreOptions), {\n      variables: __assign(__assign({}, this.options.variables), fetchMoreOptions.variables)\n    })), {\n      fetchPolicy: \"no-cache\"\n    });\n\n    var qid = this.queryManager.generateQueryId();\n\n    if (combinedOptions.notifyOnNetworkStatusChange) {\n      this.queryInfo.networkStatus = NetworkStatus.fetchMore;\n      this.observe();\n    }\n\n    return this.queryManager.fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore).then(function (fetchMoreResult) {\n      var data = fetchMoreResult.data;\n      var updateQuery = fetchMoreOptions.updateQuery;\n\n      if (updateQuery) {\n        if (__DEV__ && !warnedAboutUpdateQuery) {\n          __DEV__ && invariant.warn(\"The updateQuery callback for fetchMore is deprecated, and will be removed\\nin the next major version of Apollo Client.\\n\\nPlease convert updateQuery functions to field policies with appropriate\\nread and merge functions, or use/adapt a helper function (such as\\nconcatPagination, offsetLimitPagination, or relayStylePagination) from\\n@apollo/client/utilities.\\n\\nThe field policy system handles pagination more effectively than a\\nhand-written updateQuery function, and you only need to define the policy\\nonce, rather than every time you call fetchMore.\");\n          warnedAboutUpdateQuery = true;\n        }\n\n        _this.updateQuery(function (previous) {\n          return updateQuery(previous, {\n            fetchMoreResult: data,\n            variables: combinedOptions.variables\n          });\n        });\n      } else {\n        _this.queryManager.cache.writeQuery({\n          query: combinedOptions.query,\n          variables: combinedOptions.variables,\n          data: data\n        });\n      }\n\n      return fetchMoreResult;\n    }).finally(function () {\n      _this.queryManager.stopQuery(qid);\n\n      _this.reobserve();\n    });\n  };\n\n  ObservableQuery.prototype.subscribeToMore = function (options) {\n    var _this = this;\n\n    var subscription = this.queryManager.startGraphQLSubscription({\n      query: options.document,\n      variables: options.variables,\n      context: options.context\n    }).subscribe({\n      next: function (subscriptionData) {\n        var updateQuery = options.updateQuery;\n\n        if (updateQuery) {\n          _this.updateQuery(function (previous, _a) {\n            var variables = _a.variables;\n            return updateQuery(previous, {\n              subscriptionData: subscriptionData,\n              variables: variables\n            });\n          });\n        }\n      },\n      error: function (err) {\n        if (options.onError) {\n          options.onError(err);\n          return;\n        }\n\n        __DEV__ && invariant.error('Unhandled GraphQL subscription error', err);\n      }\n    });\n    this.subscriptions.add(subscription);\n    return function () {\n      if (_this.subscriptions.delete(subscription)) {\n        subscription.unsubscribe();\n      }\n    };\n  };\n\n  ObservableQuery.prototype.setOptions = function (newOptions) {\n    return this.reobserve(newOptions);\n  };\n\n  ObservableQuery.prototype.setVariables = function (variables) {\n    if (equal(this.variables, variables)) {\n      return this.observers.size ? this.result() : Promise.resolve();\n    }\n\n    this.options.variables = variables;\n\n    if (!this.observers.size) {\n      return Promise.resolve();\n    }\n\n    return this.reobserve({\n      fetchPolicy: this.initialFetchPolicy,\n      variables: variables\n    }, NetworkStatus.setVariables);\n  };\n\n  ObservableQuery.prototype.updateQuery = function (mapFn) {\n    var queryManager = this.queryManager;\n    var result = queryManager.cache.diff({\n      query: this.options.query,\n      variables: this.variables,\n      returnPartialData: true,\n      optimistic: false\n    }).result;\n    var newResult = mapFn(result, {\n      variables: this.variables\n    });\n\n    if (newResult) {\n      queryManager.cache.writeQuery({\n        query: this.options.query,\n        data: newResult,\n        variables: this.variables\n      });\n      queryManager.broadcastQueries();\n    }\n  };\n\n  ObservableQuery.prototype.startPolling = function (pollInterval) {\n    this.options.pollInterval = pollInterval;\n    this.updatePolling();\n  };\n\n  ObservableQuery.prototype.stopPolling = function () {\n    this.options.pollInterval = 0;\n    this.updatePolling();\n  };\n\n  ObservableQuery.prototype.fetch = function (options, newNetworkStatus) {\n    this.queryManager.setObservableQuery(this);\n    return this.queryManager.fetchQueryObservable(this.queryId, options, newNetworkStatus);\n  };\n\n  ObservableQuery.prototype.updatePolling = function () {\n    var _this = this;\n\n    if (this.queryManager.ssrMode) {\n      return;\n    }\n\n    var _a = this,\n        pollingInfo = _a.pollingInfo,\n        pollInterval = _a.options.pollInterval;\n\n    if (!pollInterval) {\n      if (pollingInfo) {\n        clearTimeout(pollingInfo.timeout);\n        delete this.pollingInfo;\n      }\n\n      return;\n    }\n\n    if (pollingInfo && pollingInfo.interval === pollInterval) {\n      return;\n    }\n\n    __DEV__ ? invariant(pollInterval, 'Attempted to start a polling query without a polling interval.') : invariant(pollInterval, 10);\n    var info = pollingInfo || (this.pollingInfo = {});\n    info.interval = pollInterval;\n\n    var maybeFetch = function () {\n      if (_this.pollingInfo) {\n        if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus)) {\n          _this.reobserve({\n            fetchPolicy: \"network-only\"\n          }, NetworkStatus.poll).then(poll, poll);\n        } else {\n          poll();\n        }\n      }\n\n      ;\n    };\n\n    var poll = function () {\n      var info = _this.pollingInfo;\n\n      if (info) {\n        clearTimeout(info.timeout);\n        info.timeout = setTimeout(maybeFetch, info.interval);\n      }\n    };\n\n    poll();\n  };\n\n  ObservableQuery.prototype.updateLastResult = function (newResult, variables) {\n    if (variables === void 0) {\n      variables = this.variables;\n    }\n\n    this.last = __assign(__assign({}, this.last), {\n      result: this.queryManager.assumeImmutableResults ? newResult : cloneDeep(newResult),\n      variables: variables\n    });\n\n    if (!isNonEmptyArray(newResult.errors)) {\n      delete this.last.error;\n    }\n\n    return this.last;\n  };\n\n  ObservableQuery.prototype.reobserve = function (newOptions, newNetworkStatus) {\n    var _this = this;\n\n    this.isTornDown = false;\n    var useDisposableConcast = newNetworkStatus === NetworkStatus.refetch || newNetworkStatus === NetworkStatus.fetchMore || newNetworkStatus === NetworkStatus.poll;\n    var oldVariables = this.options.variables;\n    var options = useDisposableConcast ? compact(this.options, newOptions) : assign(this.options, compact(newOptions));\n\n    if (!useDisposableConcast) {\n      this.updatePolling();\n\n      if (newOptions && newOptions.variables && !newOptions.fetchPolicy && !equal(newOptions.variables, oldVariables)) {\n        options.fetchPolicy = this.initialFetchPolicy;\n\n        if (newNetworkStatus === void 0) {\n          newNetworkStatus = NetworkStatus.setVariables;\n        }\n      }\n    }\n\n    var variables = options.variables && __assign({}, options.variables);\n\n    var concast = this.fetch(options, newNetworkStatus);\n    var observer = {\n      next: function (result) {\n        _this.reportResult(result, variables);\n      },\n      error: function (error) {\n        _this.reportError(error, variables);\n      }\n    };\n\n    if (!useDisposableConcast) {\n      if (this.concast && this.observer) {\n        this.concast.removeObserver(this.observer, true);\n      }\n\n      this.concast = concast;\n      this.observer = observer;\n    }\n\n    concast.addObserver(observer);\n    return concast.promise;\n  };\n\n  ObservableQuery.prototype.observe = function () {\n    this.reportResult(this.getCurrentResult(false), this.variables);\n  };\n\n  ObservableQuery.prototype.reportResult = function (result, variables) {\n    if (this.getLastError() || this.isDifferentFromLastResult(result)) {\n      this.updateLastResult(result, variables);\n      iterateObserversSafely(this.observers, 'next', result);\n    }\n  };\n\n  ObservableQuery.prototype.reportError = function (error, variables) {\n    var errorResult = __assign(__assign({}, this.getLastResult()), {\n      error: error,\n      errors: error.graphQLErrors,\n      networkStatus: NetworkStatus.error,\n      loading: false\n    });\n\n    this.updateLastResult(errorResult, variables);\n    iterateObserversSafely(this.observers, 'error', this.last.error = error);\n  };\n\n  ObservableQuery.prototype.hasObservers = function () {\n    return this.observers.size > 0;\n  };\n\n  ObservableQuery.prototype.tearDownQuery = function () {\n    if (this.isTornDown) return;\n\n    if (this.concast && this.observer) {\n      this.concast.removeObserver(this.observer);\n      delete this.concast;\n      delete this.observer;\n    }\n\n    this.stopPolling();\n    this.subscriptions.forEach(function (sub) {\n      return sub.unsubscribe();\n    });\n    this.subscriptions.clear();\n    this.queryManager.stopQuery(this.queryId);\n    this.observers.clear();\n    this.isTornDown = true;\n  };\n\n  return ObservableQuery;\n}(Observable);\n\nexport { ObservableQuery };\nfixObservableSubclass(ObservableQuery);\n\nfunction defaultSubscriptionObserverErrorCallback(error) {\n  __DEV__ && invariant.error('Unhandled error', error.message, error.stack);\n}\n\nexport function logMissingFieldErrors(missing) {\n  if (__DEV__ && missing) {\n    __DEV__ && invariant.debug(\"Missing cache result fields: \".concat(JSON.stringify(missing)), missing);\n  }\n}\nexport function applyNextFetchPolicy(options) {\n  var _a = options.fetchPolicy,\n      fetchPolicy = _a === void 0 ? \"cache-first\" : _a,\n      nextFetchPolicy = options.nextFetchPolicy;\n\n  if (nextFetchPolicy) {\n    options.fetchPolicy = typeof nextFetchPolicy === \"function\" ? nextFetchPolicy.call(options, fetchPolicy) : nextFetchPolicy;\n  }\n}","map":{"version":3,"mappings":"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","names":["invariant","equal","NetworkStatus","isNetworkRequestInFlight","compact","cloneDeep","getOperationDefinition","Observable","iterateObserversSafely","isNonEmptyArray","fixObservableSubclass","getQueryDefinition","Object","hasOwnProperty","warnedAboutUpdateQuery","__extends","_a","queryManager","queryInfo","options","_super","observer","subObserver","_subscription","_observer","error","defaultSubscriptionObserverErrorCallback","first","_this","observers","size","add","last","result","next","reobserve","catch","delete","tearDownQuery","Set","isTornDown","queryId","generateQueryId","opDef","query","queryName","name","value","initialFetchPolicy","fetchPolicy","ObservableQuery","get","variables","enumerable","configurable","Promise","resolve","reject","removeQuery","setTimeout","subscription","unsubscribe","subscribe","saveAsLastResult","lastResult","getLastResult","networkStatus","ready","__assign","loading","transform","hasForcedResolvers","diff","getDiff","complete","returnPartialData","data","partial","__DEV__","partialRefetch","logMissingFieldErrors","missing","updateLastResult","newResult","key","variablesMustMatch","getLast","resetErrors","reobserveOptions","pollInterval","call","queryDef","vars","variableDefinitions","some","variable","concat","JSON","resetLastWrite","refetch","fetchMoreOptions","combinedOptions","qid","notifyOnNetworkStatusChange","fetchMore","observe","fetchQuery","then","fetchMoreResult","updateQuery","previous","cache","writeQuery","finally","stopQuery","startGraphQLSubscription","document","context","subscriptionData","err","onError","subscriptions","newOptions","setVariables","mapFn","optimistic","broadcastQueries","updatePolling","newNetworkStatus","setObservableQuery","fetchQueryObservable","ssrMode","pollingInfo","clearTimeout","timeout","interval","info","maybeFetch","poll","assumeImmutableResults","errors","useDisposableConcast","oldVariables","assign","concast","fetch","reportResult","reportError","removeObserver","addObserver","promise","getCurrentResult","getLastError","isDifferentFromLastResult","errorResult","graphQLErrors","stopPolling","forEach","clear","applyNextFetchPolicy","nextFetchPolicy"],"sources":["../../src/core/ObservableQuery.ts"],"sourcesContent":["import { invariant } from '../utilities/globals';\n\nimport { equal } from '@wry/equality';\n\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport {\n  Concast,\n  compact,\n  cloneDeep,\n  getOperationDefinition,\n  Observable,\n  Observer,\n  ObservableSubscription,\n  iterateObserversSafely,\n  isNonEmptyArray,\n  fixObservableSubclass,\n  getQueryDefinition,\n} from '../utilities';\nimport { ApolloError } from '../errors';\nimport { QueryManager } from './QueryManager';\nimport { ApolloQueryResult, OperationVariables } from './types';\nimport {\n  WatchQueryOptions,\n  FetchMoreQueryOptions,\n  SubscribeToMoreOptions,\n  WatchQueryFetchPolicy,\n} from './watchQueryOptions';\nimport { QueryInfo } from './QueryInfo';\nimport { MissingFieldError } from '../cache';\nimport { MissingTree } from '../cache/core/types/common';\n\nconst {\n  assign,\n  hasOwnProperty,\n} = Object;\n\nexport interface FetchMoreOptions<\n  TData = any,\n  TVariables = OperationVariables\n> {\n  updateQuery?: (\n    previousQueryResult: TData,\n    options: {\n      fetchMoreResult?: TData;\n      variables?: TVariables;\n    },\n  ) => TData;\n}\n\nexport interface UpdateQueryOptions<TVariables> {\n  variables?: TVariables;\n}\n\nlet warnedAboutUpdateQuery = false;\n\ninterface Last<TData, TVariables> {\n  result: ApolloQueryResult<TData>;\n  variables?: TVariables;\n  error?: ApolloError;\n}\n\nexport class ObservableQuery<\n  TData = any,\n  TVariables = OperationVariables\n> extends Observable<ApolloQueryResult<TData>> {\n  public readonly options: WatchQueryOptions<TVariables, TData>;\n  public readonly queryId: string;\n  public readonly queryName?: string;\n\n  // Computed shorthand for this.options.variables, preserved for\n  // backwards compatibility.\n  public get variables(): TVariables | undefined {\n    return this.options.variables;\n  }\n\n  // Original value of this.options.fetchPolicy (defaulting to \"cache-first\"),\n  // from whenever the ObservableQuery was first created.\n  private initialFetchPolicy: WatchQueryFetchPolicy;\n\n  private isTornDown: boolean;\n  private queryManager: QueryManager<any>;\n  private observers = new Set<Observer<ApolloQueryResult<TData>>>();\n  private subscriptions = new Set<ObservableSubscription>();\n\n  private last?: Last<TData, TVariables>;\n\n  private queryInfo: QueryInfo;\n\n  // When this.concast is defined, this.observer is the Observer currently\n  // subscribed to that Concast.\n  private concast?: Concast<ApolloQueryResult<TData>>;\n  private observer?: Observer<ApolloQueryResult<TData>>;\n\n  private pollingInfo?: {\n    interval: number;\n    timeout: ReturnType<typeof setTimeout>;\n  };\n\n  constructor({\n    queryManager,\n    queryInfo,\n    options,\n  }: {\n    queryManager: QueryManager<any>;\n    queryInfo: QueryInfo;\n    options: WatchQueryOptions<TVariables, TData>;\n  }) {\n    super((observer: Observer<ApolloQueryResult<TData>>) => {\n      // Zen Observable has its own error function, so in order to log correctly\n      // we need to provide a custom error callback.\n      try {\n        var subObserver = (observer as any)._subscription._observer;\n        if (subObserver && !subObserver.error) {\n          subObserver.error = defaultSubscriptionObserverErrorCallback;\n        }\n      } catch {}\n\n      const first = !this.observers.size;\n      this.observers.add(observer);\n\n      // Deliver most recent error or result.\n      const last = this.last;\n      if (last && last.error) {\n        observer.error && observer.error(last.error);\n      } else if (last && last.result) {\n        observer.next && observer.next(last.result);\n      }\n\n      // Initiate observation of this query if it hasn't been reported to\n      // the QueryManager yet.\n      if (first) {\n        // Blindly catching here prevents unhandled promise rejections,\n        // and is safe because the ObservableQuery handles this error with\n        // this.observer.error, so we're not just swallowing the error by\n        // ignoring it here.\n        this.reobserve().catch(() => {});\n      }\n\n      return () => {\n        if (this.observers.delete(observer) && !this.observers.size) {\n          this.tearDownQuery();\n        }\n      };\n    });\n\n    // active state\n    this.isTornDown = false;\n\n    // query information\n    this.options = options;\n    this.queryId = queryInfo.queryId || queryManager.generateQueryId();\n\n    const opDef = getOperationDefinition(options.query);\n    this.queryName = opDef && opDef.name && opDef.name.value;\n\n    this.initialFetchPolicy = options.fetchPolicy || \"cache-first\";\n\n    // related classes\n    this.queryManager = queryManager;\n    this.queryInfo = queryInfo;\n  }\n\n  public result(): Promise<ApolloQueryResult<TData>> {\n    return new Promise((resolve, reject) => {\n      // TODO: this code doesn’t actually make sense insofar as the observer\n      // will never exist in this.observers due how zen-observable wraps observables.\n      // https://github.com/zenparsing/zen-observable/blob/master/src/Observable.js#L169\n      const observer: Observer<ApolloQueryResult<TData>> = {\n        next: (result: ApolloQueryResult<TData>) => {\n          resolve(result);\n\n          // Stop the query within the QueryManager if we can before\n          // this function returns.\n          //\n          // We do this in order to prevent observers piling up within\n          // the QueryManager. Notice that we only fully unsubscribe\n          // from the subscription in a setTimeout(..., 0)  call. This call can\n          // actually be handled by the browser at a much later time. If queries\n          // are fired in the meantime, observers that should have been removed\n          // from the QueryManager will continue to fire, causing an unnecessary\n          // performance hit.\n          this.observers.delete(observer);\n          if (!this.observers.size) {\n            this.queryManager.removeQuery(this.queryId);\n          }\n\n          setTimeout(() => {\n            subscription.unsubscribe();\n          }, 0);\n        },\n        error: reject,\n      };\n      const subscription = this.subscribe(observer);\n    });\n  }\n\n  public getCurrentResult(saveAsLastResult = true): ApolloQueryResult<TData> {\n    // Use the last result as long as the variables match this.variables.\n    const lastResult = this.getLastResult(true);\n\n    const networkStatus =\n      this.queryInfo.networkStatus ||\n      (lastResult && lastResult.networkStatus) ||\n      NetworkStatus.ready;\n\n    const result = {\n      ...lastResult,\n      loading: isNetworkRequestInFlight(networkStatus),\n      networkStatus,\n    } as ApolloQueryResult<TData>;\n\n    const { fetchPolicy = \"cache-first\" } = this.options;\n    if (\n      // These fetch policies should never deliver data from the cache, unless\n      // redelivering a previously delivered result.\n      fetchPolicy === 'network-only' ||\n      fetchPolicy === 'no-cache' ||\n      fetchPolicy === 'standby' ||\n      // If this.options.query has @client(always: true) fields, we cannot\n      // trust diff.result, since it was read from the cache without running\n      // local resolvers (and it's too late to run resolvers now, since we must\n      // return a result synchronously).\n      this.queryManager.transform(this.options.query).hasForcedResolvers\n    ) {\n      // Fall through.\n    } else {\n      const diff = this.queryInfo.getDiff();\n\n      if (diff.complete || this.options.returnPartialData) {\n        result.data = diff.result;\n      }\n\n      if (equal(result.data, {})) {\n        result.data = void 0 as any;\n      }\n\n      if (diff.complete) {\n        // Similar to setting result.partial to false, but taking advantage of the\n        // falsiness of missing fields.\n        delete result.partial;\n\n        // If the diff is complete, and we're using a FetchPolicy that\n        // terminates after a complete cache read, we can assume the next result\n        // we receive will have NetworkStatus.ready and !loading.\n        if (\n          diff.complete &&\n          result.networkStatus === NetworkStatus.loading &&\n          (fetchPolicy === 'cache-first' ||\n          fetchPolicy === 'cache-only')\n        ) {\n          result.networkStatus = NetworkStatus.ready;\n          result.loading = false;\n        }\n      } else {\n        result.partial = true;\n      }\n\n      if (\n        __DEV__ &&\n        !diff.complete &&\n        !this.options.partialRefetch &&\n        !result.loading &&\n        !result.data &&\n        !result.error\n      ) {\n        logMissingFieldErrors(diff.missing);\n      }\n    }\n\n    if (saveAsLastResult) {\n      this.updateLastResult(result);\n    }\n\n    return result;\n  }\n\n  // Compares newResult to the snapshot we took of this.lastResult when it was\n  // first received.\n  public isDifferentFromLastResult(newResult: ApolloQueryResult<TData>) {\n    return !this.last || !equal(this.last.result, newResult);\n  }\n\n  private getLast<K extends keyof Last<TData, TVariables>>(\n    key: K,\n    variablesMustMatch?: boolean,\n  ) {\n    const last = this.last;\n    if (last &&\n        last[key] &&\n        (!variablesMustMatch || equal(last!.variables, this.variables))) {\n      return last[key];\n    }\n  }\n\n  public getLastResult(variablesMustMatch?: boolean): ApolloQueryResult<TData> | undefined {\n    return this.getLast(\"result\", variablesMustMatch);\n  }\n\n  public getLastError(variablesMustMatch?: boolean): ApolloError | undefined {\n    return this.getLast(\"error\", variablesMustMatch);\n  }\n\n  public resetLastResults(): void {\n    delete this.last;\n    this.isTornDown = false;\n  }\n\n  public resetQueryStoreErrors() {\n    this.queryManager.resetErrors(this.queryId);\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public refetch(variables?: Partial<TVariables>): Promise<ApolloQueryResult<TData>> {\n    const reobserveOptions: Partial<WatchQueryOptions<TVariables, TData>> = {\n      // Always disable polling for refetches.\n      pollInterval: 0,\n    };\n\n    // Unless the provided fetchPolicy always consults the network\n    // (no-cache, network-only, or cache-and-network), override it with\n    // network-only to force the refetch for this fetchQuery call.\n    const { fetchPolicy } = this.options;\n    if (fetchPolicy === 'cache-and-network') {\n      reobserveOptions.fetchPolicy = fetchPolicy;\n    } else if (fetchPolicy === 'no-cache') {\n      reobserveOptions.fetchPolicy = 'no-cache';\n    } else {\n      reobserveOptions.fetchPolicy = 'network-only';\n    }\n\n    if (__DEV__ && variables && hasOwnProperty.call(variables, \"variables\")) {\n      const queryDef = getQueryDefinition(this.options.query);\n      const vars = queryDef.variableDefinitions;\n      if (!vars || !vars.some(v => v.variable.name.value === \"variables\")) {\n        invariant.warn(`Called refetch(${\n          JSON.stringify(variables)\n        }) for query ${\n          queryDef.name?.value || JSON.stringify(queryDef)\n        }, which does not declare a $variables variable.\nDid you mean to call refetch(variables) instead of refetch({ variables })?`);\n      }\n    }\n\n    if (variables && !equal(this.options.variables, variables)) {\n      // Update the existing options with new variables\n      reobserveOptions.variables = this.options.variables = {\n        ...this.options.variables,\n        ...variables,\n      } as TVariables;\n    }\n\n    this.queryInfo.resetLastWrite();\n    return this.reobserve(reobserveOptions, NetworkStatus.refetch);\n  }\n\n  public fetchMore(\n    fetchMoreOptions: FetchMoreQueryOptions<TVariables, TData> &\n      FetchMoreOptions<TData, TVariables>,\n  ): Promise<ApolloQueryResult<TData>> {\n    const combinedOptions = {\n      ...(fetchMoreOptions.query ? fetchMoreOptions : {\n        ...this.options,\n        ...fetchMoreOptions,\n        variables: {\n          ...this.options.variables,\n          ...fetchMoreOptions.variables,\n        },\n      }),\n      // The fetchMore request goes immediately to the network and does\n      // not automatically write its result to the cache (hence no-cache\n      // instead of network-only), because we allow the caller of\n      // fetchMore to provide an updateQuery callback that determines how\n      // the data gets written to the cache.\n      fetchPolicy: \"no-cache\",\n    } as WatchQueryOptions;\n\n    const qid = this.queryManager.generateQueryId();\n\n    // Simulate a loading result for the original query with\n    // result.networkStatus === NetworkStatus.fetchMore.\n    if (combinedOptions.notifyOnNetworkStatusChange) {\n      this.queryInfo.networkStatus = NetworkStatus.fetchMore;\n      this.observe();\n    }\n\n    return this.queryManager.fetchQuery(\n      qid,\n      combinedOptions,\n      NetworkStatus.fetchMore,\n    ).then(fetchMoreResult => {\n      const data = fetchMoreResult.data as TData;\n      const { updateQuery } = fetchMoreOptions;\n\n      if (updateQuery) {\n        if (__DEV__ &&\n            !warnedAboutUpdateQuery) {\n          invariant.warn(\n`The updateQuery callback for fetchMore is deprecated, and will be removed\nin the next major version of Apollo Client.\n\nPlease convert updateQuery functions to field policies with appropriate\nread and merge functions, or use/adapt a helper function (such as\nconcatPagination, offsetLimitPagination, or relayStylePagination) from\n@apollo/client/utilities.\n\nThe field policy system handles pagination more effectively than a\nhand-written updateQuery function, and you only need to define the policy\nonce, rather than every time you call fetchMore.`);\n          warnedAboutUpdateQuery = true;\n        }\n        this.updateQuery(previous => updateQuery(previous, {\n          fetchMoreResult: data,\n          variables: combinedOptions.variables as TVariables,\n        }));\n      } else {\n        // If we're using a field policy instead of updateQuery, the only\n        // thing we need to do is write the new data to the cache using\n        // combinedOptions.variables (instead of this.variables, which is\n        // what this.updateQuery uses, because it works by abusing the\n        // original field value, keyed by the original variables).\n        this.queryManager.cache.writeQuery({\n          query: combinedOptions.query,\n          variables: combinedOptions.variables,\n          data,\n        });\n      }\n\n      return fetchMoreResult as ApolloQueryResult<TData>;\n\n    }).finally(() => {\n      this.queryManager.stopQuery(qid);\n      this.reobserve();\n    });\n  }\n\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  public subscribeToMore<\n    TSubscriptionData = TData,\n    TSubscriptionVariables = TVariables\n  >(\n    options: SubscribeToMoreOptions<\n      TData,\n      TSubscriptionVariables,\n      TSubscriptionData\n    >,\n  ) {\n    const subscription = this.queryManager\n      .startGraphQLSubscription({\n        query: options.document,\n        variables: options.variables,\n        context: options.context,\n      })\n      .subscribe({\n        next: (subscriptionData: { data: TSubscriptionData }) => {\n          const { updateQuery } = options;\n          if (updateQuery) {\n            this.updateQuery<TSubscriptionVariables>(\n              (previous, { variables }) =>\n                updateQuery(previous, {\n                  subscriptionData,\n                  variables,\n                }),\n            );\n          }\n        },\n        error: (err: any) => {\n          if (options.onError) {\n            options.onError(err);\n            return;\n          }\n          invariant.error('Unhandled GraphQL subscription error', err);\n        },\n      });\n\n    this.subscriptions.add(subscription);\n\n    return () => {\n      if (this.subscriptions.delete(subscription)) {\n        subscription.unsubscribe();\n      }\n    };\n  }\n\n  public setOptions(\n    newOptions: Partial<WatchQueryOptions<TVariables, TData>>,\n  ): Promise<ApolloQueryResult<TData>> {\n    return this.reobserve(newOptions);\n  }\n\n  /**\n   * This is for *internal* use only. Most users should instead use `refetch`\n   * in order to be properly notified of results even when they come from cache.\n   *\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. If you want to force new results, use `refetch`.\n   *\n   * Note: the `next` callback will *not* fire if the variables have not changed\n   * or if the result is coming from cache.\n   *\n   * Note: the promise will return the old results immediately if the variables\n   * have not changed.\n   *\n   * Note: the promise will return null immediately if the query is not active\n   * (there are no subscribers).\n   *\n   * @private\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public setVariables(\n    variables: TVariables,\n  ): Promise<ApolloQueryResult<TData> | void> {\n    if (equal(this.variables, variables)) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      return this.observers.size\n        ? this.result()\n        : Promise.resolve();\n    }\n\n    this.options.variables = variables;\n\n    // See comment above\n    if (!this.observers.size) {\n      return Promise.resolve();\n    }\n\n    return this.reobserve({\n      // Reset options.fetchPolicy to its original value.\n      fetchPolicy: this.initialFetchPolicy,\n      variables,\n    }, NetworkStatus.setVariables);\n  }\n\n  public updateQuery<TVars = TVariables>(\n    mapFn: (\n      previousQueryResult: TData,\n      options: Pick<WatchQueryOptions<TVars, TData>, \"variables\">,\n    ) => TData,\n  ): void {\n    const { queryManager } = this;\n    const { result } = queryManager.cache.diff<TData>({\n      query: this.options.query,\n      variables: this.variables,\n      returnPartialData: true,\n      optimistic: false,\n    });\n\n    const newResult = mapFn(result!, {\n      variables: (this as any).variables,\n    });\n\n    if (newResult) {\n      queryManager.cache.writeQuery({\n        query: this.options.query,\n        data: newResult,\n        variables: this.variables,\n      });\n\n      queryManager.broadcastQueries();\n    }\n  }\n\n  public startPolling(pollInterval: number) {\n    this.options.pollInterval = pollInterval;\n    this.updatePolling();\n  }\n\n  public stopPolling() {\n    this.options.pollInterval = 0;\n    this.updatePolling();\n  }\n\n  private fetch(\n    options: WatchQueryOptions<TVariables, TData>,\n    newNetworkStatus?: NetworkStatus,\n  ): Concast<ApolloQueryResult<TData>> {\n    this.queryManager.setObservableQuery(this);\n    return this.queryManager.fetchQueryObservable(\n      this.queryId,\n      options,\n      newNetworkStatus,\n    );\n  }\n\n  // Turns polling on or off based on this.options.pollInterval.\n  private updatePolling() {\n    // Avoid polling in SSR mode\n    if (this.queryManager.ssrMode) {\n      return;\n    }\n\n    const {\n      pollingInfo,\n      options: {\n        pollInterval,\n      },\n    } = this;\n\n    if (!pollInterval) {\n      if (pollingInfo) {\n        clearTimeout(pollingInfo.timeout);\n        delete this.pollingInfo;\n      }\n      return;\n    }\n\n    if (pollingInfo &&\n        pollingInfo.interval === pollInterval) {\n      return;\n    }\n\n    invariant(\n      pollInterval,\n      'Attempted to start a polling query without a polling interval.',\n    );\n\n    const info = pollingInfo || (this.pollingInfo = {} as any);\n    info.interval = pollInterval;\n\n    const maybeFetch = () => {\n      if (this.pollingInfo) {\n        if (!isNetworkRequestInFlight(this.queryInfo.networkStatus)) {\n          this.reobserve({\n            fetchPolicy: \"network-only\",\n          }, NetworkStatus.poll).then(poll, poll);\n        } else {\n          poll();\n        }\n      };\n    };\n\n    const poll = () => {\n      const info = this.pollingInfo;\n      if (info) {\n        clearTimeout(info.timeout);\n        info.timeout = setTimeout(maybeFetch, info.interval);\n      }\n    };\n\n    poll();\n  }\n\n  private updateLastResult(\n    newResult: ApolloQueryResult<TData>,\n    variables = this.variables,\n  ) {\n    this.last = {\n      ...this.last,\n      result: this.queryManager.assumeImmutableResults\n        ? newResult\n        : cloneDeep(newResult),\n      variables,\n    };\n    if (!isNonEmptyArray(newResult.errors)) {\n      delete this.last.error;\n    }\n    return this.last;\n  }\n\n  public reobserve(\n    newOptions?: Partial<WatchQueryOptions<TVariables, TData>>,\n    newNetworkStatus?: NetworkStatus,\n  ): Promise<ApolloQueryResult<TData>> {\n    this.isTornDown = false;\n\n    const useDisposableConcast =\n      // Refetching uses a disposable Concast to allow refetches using different\n      // options/variables, without permanently altering the options of the\n      // original ObservableQuery.\n      newNetworkStatus === NetworkStatus.refetch ||\n      // The fetchMore method does not actually call the reobserve method, but,\n      // if it did, it would definitely use a disposable Concast.\n      newNetworkStatus === NetworkStatus.fetchMore ||\n      // Polling uses a disposable Concast so the polling options (which force\n      // fetchPolicy to be \"network-only\") won't override the original options.\n      newNetworkStatus === NetworkStatus.poll;\n\n    // Save the old variables, since Object.assign may modify them below.\n    const oldVariables = this.options.variables;\n\n    const options = useDisposableConcast\n      // Disposable Concast fetches receive a shallow copy of this.options\n      // (merged with newOptions), leaving this.options unmodified.\n      ? compact(this.options, newOptions)\n      : assign(this.options, compact(newOptions));\n\n    if (!useDisposableConcast) {\n      // We can skip calling updatePolling if we're not changing this.options.\n      this.updatePolling();\n\n      // Reset options.fetchPolicy to its original value when variables change,\n      // unless a new fetchPolicy was provided by newOptions.\n      if (\n        newOptions &&\n        newOptions.variables &&\n        !newOptions.fetchPolicy &&\n        !equal(newOptions.variables, oldVariables)\n      ) {\n        options.fetchPolicy = this.initialFetchPolicy;\n        if (newNetworkStatus === void 0) {\n          newNetworkStatus = NetworkStatus.setVariables;\n        }\n      }\n    }\n\n    const variables = options.variables && { ...options.variables };\n    const concast = this.fetch(options, newNetworkStatus);\n    const observer: Observer<ApolloQueryResult<TData>> = {\n      next: result => {\n        this.reportResult(result, variables);\n      },\n      error: error => {\n        this.reportError(error, variables);\n      },\n    };\n\n    if (!useDisposableConcast) {\n      // We use the {add,remove}Observer methods directly to avoid wrapping\n      // observer with an unnecessary SubscriptionObserver object, in part so\n      // that we can remove it here without triggering any unsubscriptions,\n      // because we just want to ignore the old observable, not prematurely shut\n      // it down, since other consumers may be awaiting this.concast.promise.\n      if (this.concast && this.observer) {\n        this.concast.removeObserver(this.observer, true);\n      }\n\n      this.concast = concast;\n      this.observer = observer;\n    }\n\n    concast.addObserver(observer);\n\n    return concast.promise;\n  }\n\n  // Pass the current result to this.observer.next without applying any\n  // fetch policies.\n  private observe() {\n    // Passing false is important so that this.getCurrentResult doesn't\n    // save the fetchMore result as this.lastResult, causing it to be\n    // ignored due to the this.isDifferentFromLastResult check in\n    // this.observer.next.\n    this.reportResult(\n      this.getCurrentResult(false),\n      this.variables,\n    );\n  }\n\n  private reportResult(\n    result: ApolloQueryResult<TData>,\n    variables: TVariables | undefined,\n  ) {\n    if (this.getLastError() || this.isDifferentFromLastResult(result)) {\n      this.updateLastResult(result, variables);\n      iterateObserversSafely(this.observers, 'next', result);\n    }\n  }\n\n  private reportError(\n    error: ApolloError,\n    variables: TVariables | undefined,\n  ) {\n    // Since we don't get the current result on errors, only the error, we\n    // must mirror the updates that occur in QueryStore.markQueryError here\n    const errorResult = {\n      ...this.getLastResult(),\n      error,\n      errors: error.graphQLErrors,\n      networkStatus: NetworkStatus.error,\n      loading: false,\n    } as ApolloQueryResult<TData>;\n\n    this.updateLastResult(errorResult, variables);\n\n    iterateObserversSafely(this.observers, 'error', this.last!.error = error);\n  }\n\n  public hasObservers() {\n    return this.observers.size > 0;\n  }\n\n  private tearDownQuery() {\n    if (this.isTornDown) return;\n    if (this.concast && this.observer) {\n      this.concast.removeObserver(this.observer);\n      delete this.concast;\n      delete this.observer;\n    }\n\n    this.stopPolling();\n    // stop all active GraphQL subscriptions\n    this.subscriptions.forEach(sub => sub.unsubscribe());\n    this.subscriptions.clear();\n    this.queryManager.stopQuery(this.queryId);\n    this.observers.clear();\n    this.isTornDown = true;\n  }\n}\n\n// Necessary because the ObservableQuery constructor has a different\n// signature than the Observable constructor.\nfixObservableSubclass(ObservableQuery);\n\nfunction defaultSubscriptionObserverErrorCallback(error: ApolloError) {\n  invariant.error('Unhandled error', error.message, error.stack);\n}\n\nexport function logMissingFieldErrors(\n  missing: MissingFieldError[] | MissingTree | undefined,\n) {\n  if (__DEV__ && missing) {\n    invariant.debug(`Missing cache result fields: ${\n      JSON.stringify(missing)\n    }`, missing);\n  }\n}\n\n// Adopt options.nextFetchPolicy (if defined) as a replacement for\n// options.fetchPolicy. Since this method also removes options.nextFetchPolicy\n// from options, the adoption tends to be idempotent, unless nextFetchPolicy\n// is a function that keeps setting options.nextFetchPolicy (uncommon).\nexport function applyNextFetchPolicy<TData, TVars>(\n  options: Pick<\n    WatchQueryOptions<TVars, TData>,\n    | \"fetchPolicy\"\n    | \"nextFetchPolicy\"\n  >,\n) {\n  const {\n    fetchPolicy = \"cache-first\",\n    nextFetchPolicy,\n  } = options;\n\n  if (nextFetchPolicy) {\n    // When someone chooses \"cache-and-network\" or \"network-only\" as their\n    // initial FetchPolicy, they often do not want future cache updates to\n    // trigger unconditional network requests, which is what repeatedly\n    // applying the \"cache-and-network\" or \"network-only\" policies would seem\n    // to imply. Instead, when the cache reports an update after the initial\n    // network request, it may be desirable for subsequent network requests to\n    // be triggered only if the cache result is incomplete. To that end, the\n    // options.nextFetchPolicy option provides an easy way to update\n    // options.fetchPolicy after the initial network request, without having to\n    // call observableQuery.setOptions.\n    options.fetchPolicy = typeof nextFetchPolicy === \"function\"\n      ? nextFetchPolicy.call(options, fetchPolicy)\n      : nextFetchPolicy;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}